# 어댑터 패턴

---

## 1.오래된 코드
#### 1.1 거인의 어깨
> 새로운 기능을 만들기 위해 오래된 코드를 참고하거나 기존의 코드를 재사용  
> 이전 코드를 재사용하면서 새로운 코드를 재창조하는것.

#### 1.2 코드의 변화
> 이전 코드를 재사용하기 위해서는 변환(변형) 작업이 필요

#### 1.3 재사용을 위한 코드 변화
> 현대의 소프트웨어는 수많은 코드를 어떻게 사용할 할까?   
> 이전 코드를 현재 상황에 맞게 동작할 수 있도록 변환하는것

#### 1.4 인터페이스
> 기존 코드를 재사용하기 위해서는 동작 변환 작업뿐 아니라 외부적인 인터페이스 형식도 일치  
> 대부분의 코드 변환 작업은 내부적의 기능적 요인보다 외부적인 인터페이스를 변환하는 작업이 많다.

---
## 2. 잘못된 코드

#### 2.1 오류코드
> 오류는 언제나 존재, 소프트웨어는 개발 과정도 중요하지만 안정적인 코드 동작과 유지보수도 매우 중요

#### 2.2 수정불가
> 재사용된 기능 중 일부 코드는 수정할 수 없는 것도 있다.  
> 기능을 유지 보수할 수 없고 문제를 직접 해야 해야 할때 오류가 포함된 코드를 감싸서 보정 코드를 만들어 사용

#### 2.3 보정 코드
> 보정 코드는 발생한 오류를 수정하고 기능을 변경, 보정 코드는 조건을 다르게 처리하여 코드를 호출  
> 보정만을 위해 설계된 객체를 어댑터 패턴
> 어댑터 패턴은 수정 불가능한 문제를 분리된 객체로 쉽게 해결할 수 있도록 도와준다.

---

## 3. 어댑터
> 어댑터 패턴은 코드를 재사용하기 위한 인터페이스를 처리하고 인터페이스를 활용해 보정 코드를 작성

#### 3.1 코드의 래퍼 처리
> 래퍼 처리로 기존의 기능은 유지하면서 변경된 추가 코드를 삽입.

#### 3.2 호환성
> 문제점을 가진 객체를 래처하면 새로운 객체가 된다. 새로 생성되는 객체는 클라이언트-어댑티 간 호환을 위해 인터페이스를 갖고 있다.  
> 어댑터는 어댑티가 클라이언트와 통신할 수 있도록 인터페이스의 구조를 변경  

#### 3.3 중개 행동 패턴
> 래퍼 처리된 새로운 객체는 기존의 코드와 새로운 환경 간의 역할을 중개  
> 어댑티가 원활한 중개를 하기 위해 인터페이스를 재설계

#### 3.4 어댑터 종류
> 구조를 개선하는 방법은 클래스의 상속, 구성을 이용한 방법
1. 클래스 어댑터: 상속
2. 객체 어댑터: 구성

#### 3.5 클라이언트
> 어댑터 패턴을 적용하면 클라이언트 입장에서는 변화된 것이 없는 것처럼 사용할 수 있다.  
> 중간 역할의 어댑터가 내부적으로 처리 로직을 변경하여 동작을 수행

---

## 4. 클래스 어댑터
> 클래스 업대터는 다중 상속 필요 (요즘 누가 다중 상속 하냐...)

---

## 5. 객체 어댑터
> 객체 어댑터는 객체의 의존성을 이용

#### 5.1 구성
> 객체 어댑터는 내부적으로 객체를 재구성, 구성을 위해 기존 객체는 복합 객체로 변환  
> 객체 어댑터의 구성은 변환될 객체를 의존성 관계로 연결

#### 5.2 캡슐화
> 어댑터는 인터페이스를 변경, 어댑터는 변경된 인터페이스로 캡슐화 클라이언트에서 변화를 눈치채지 못한 채 그대로 사용

#### 5.3 장점
> 객체를 구성으로 결합하면 연결 방식으로 보다 많은 유연성 확보

#### 5.4 단점
> 새로운 메서드를 재구성할 때 추가 코드가 필요, 어댑터 패턴 적용으로 프로그램의 코드 증가

---

## 6. 설계
#### 6.1 기존코드
```java
public class Math {
    public float twoTime(float num) {
        System.out.println("실수 2배 적용합니다.");
        return num * 2;
    }

    public float halfTime(float num) {
        System.out.println("실수 1/2배 적용합니다.");
        return num / 2;
    }
}
```
#### 6.2 시스템 변화와 인터페이스 변경

#### 6.3 어댑터 제작
```java
// 어댑터 인터페이스
public interface Adapter {
    public int twiceOf(int num);
    public int halfOf(int num);
}
```
```java
public class Objects implements Adapter {
    private Math adapter;

    public Objects() {
        this.adapter = new Math();
    }

    @Override
    public int twiceOf(int num) {
        // 캐스팅을 통해 정수로 변환하여 반환
        return (int) this.adapter.twoTime(num);
    }

    @Override
    public int halfOf(int num) {
        // 캐스팅을 통해 정수로 변환하여 반환
        return (int) this.adapter.halfTime(num);
    }
}
```

#### 6.4 실행
```java
    void test01() {
        final Objects obj = new Objects();
        Assertions.assertThat(obj.twiceOf(5)).isEqualTo(10);
        Assertions.assertThat(obj.halfOf(4)).isEqualTo(2);
    }
``` 

#### 6.5 결과
> 어댑터 패턴은 한 개의 Adapter 클래스를 이용해 여러 개의 Adaptee 클래스를 연결함으로써 문제를 해결
> 어댑터 패턴은 새로운 인터페이스를 재정의하여 기존의 행동을 변경